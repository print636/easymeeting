# 分布式概念与实现方案

## 📚 概念解释

### 1. 分布式（Distributed System）

**定义**：分布式系统是由多个独立的计算机节点组成的系统，这些节点通过网络连接，协同工作来完成共同的任务。

**特点**：
- 多个节点（服务器）独立运行
- 节点之间通过网络通信
- 对外提供统一的服务
- 可以水平扩展（增加服务器）

**举例**：
- **单机系统**：1台服务器运行所有功能
- **分布式系统**：3台服务器，分别处理用户请求、存储数据、处理消息

### 2. 分布式环境（Distributed Environment）

**定义**：指系统部署在多台服务器上的运行环境。

**你的项目中的分布式环境**：
- 多台服务器同时运行 EasyMeeting 应用
- 每台服务器都可以处理用户请求
- 通过 Redis/RabbitMQ 进行消息通信
- 共享同一个 MySQL 数据库和 Redis 缓存

**为什么需要分布式环境**：
- **高可用**：一台服务器挂了，其他服务器继续服务
- **负载均衡**：多台服务器分担请求压力
- **性能提升**：多台服务器并行处理，提高吞吐量

### 3. 分布式锁（Distributed Lock）

**定义**：在分布式环境下，多个服务器节点需要协调访问共享资源时使用的锁机制。

**为什么需要分布式锁**：
在分布式环境下，多个服务器可能同时执行同一个操作，导致数据不一致。

**经典场景**：
```
服务器A：用户注册，检查邮箱是否存在 → 不存在 → 插入用户
服务器B：用户注册，检查邮箱是否存在 → 不存在 → 插入用户
结果：两个服务器都认为邮箱不存在，都插入了，导致重复数据！
```

**解决方案**：使用分布式锁
```
服务器A：获取锁 → 检查邮箱 → 插入用户 → 释放锁
服务器B：尝试获取锁 → 等待 → 获取锁 → 检查邮箱（已存在）→ 释放锁
```

---

## 🔍 项目中可以使用分布式锁的场景

### 场景1：用户注册（防止重复邮箱）

**问题**：多台服务器同时注册相同邮箱，可能产生重复数据

**位置**：`UserInfoServiceImpl.register()`

**当前代码**：
```java
UserInfo userInfo = this.userInfoMapper.selectByEmail(email);
if(userInfo != null){
    throw new BusinessException("邮箱账号已经存在");
}
// 插入用户
```

**问题**：在检查和插入之间，其他服务器可能也通过了检查

### 场景2：用户登录（防止重复登录）

**问题**：多台服务器同时处理同一用户的登录请求

**位置**：`UserInfoServiceImpl.login()`

**当前代码**：
```java
if(userInfo.getLastLoginTime() != null && userInfo.getLastOffTime() <= userInfo.getLastLoginTime()){
    throw new BusinessException("此账号已在别处登录");
}
// 更新登录时间
```

**问题**：并发登录时，可能都通过了检查

### 场景3：会议创建（防止重复会议号）

**问题**：多台服务器同时创建会议，可能生成相同的会议号

**位置**：`MeetingInfoServiceImpl.quickMeeting()`

### 场景4：会议加入（防止重复加入）

**问题**：同一用户在多台服务器上同时加入会议

**位置**：`MeetingInfoServiceImpl.joinMeeting()`

### 场景5：好友申请处理（防止重复处理）

**问题**：同一好友申请被多台服务器同时处理

**位置**：`UserContactApplyServiceImpl` 相关方法

---

## 💡 实现方案

### 方案1：使用 Redisson 分布式锁（推荐）

Redisson 提供了简单易用的分布式锁 API。

#### 1. 创建分布式锁工具类

```java
package com.easymeeting.redis;

import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.springframework.stereotype.Component;

import javax.annotation.Resource;
import java.util.concurrent.TimeUnit;

@Component
public class DistributedLockUtil {
    
    @Resource
    private RedissonClient redissonClient;
    
    /**
     * 尝试获取锁
     * @param lockKey 锁的key
     * @param waitTime 等待时间（秒）
     * @param leaseTime 锁的持有时间（秒），-1表示不自动释放
     * @return 是否获取成功
     */
    public boolean tryLock(String lockKey, long waitTime, long leaseTime) {
        RLock lock = redissonClient.getLock(lockKey);
        try {
            return lock.tryLock(waitTime, leaseTime, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        }
    }
    
    /**
     * 释放锁
     */
    public void unlock(String lockKey) {
        RLock lock = redissonClient.getLock(lockKey);
        if (lock.isHeldByCurrentThread()) {
            lock.unlock();
        }
    }
    
    /**
     * 执行带锁的操作
     */
    public <T> T executeWithLock(String lockKey, long waitTime, long leaseTime, LockCallback<T> callback) {
        if (tryLock(lockKey, waitTime, leaseTime)) {
            try {
                return callback.execute();
            } finally {
                unlock(lockKey);
            }
        }
        throw new BusinessException("获取锁失败，请稍后重试");
    }
    
    @FunctionalInterface
    public interface LockCallback<T> {
        T execute();
    }
}
```

#### 2. 在用户注册中使用分布式锁

```java
@Override
public void register(String email, String nickName, String password) {
    String lockKey = "lock:user:register:" + email;
    
    distributedLockUtil.executeWithLock(lockKey, 3, 10, () -> {
        // 在锁内执行注册逻辑
        UserInfo userInfo = this.userInfoMapper.selectByEmail(email);
        if(userInfo != null){
            throw new BusinessException("邮箱账号已经存在");
        }
        
        Date curDate = new Date();
        String userId = StringTools.getRandomNumber(Constants.LENGTH_12);
        userInfo = new UserInfo();
        userInfo.setUserId(userId);
        userInfo.setNickName(nickName);
        userInfo.setEmail(email);
        userInfo.setPassword(StringTools.encodeByMD5(password));
        userInfo.setCreateTime(curDate);
        userInfo.setLastOffTime(curDate.getTime());
        userInfo.setMeetingNo(StringTools.getMeetingNoOrMeetingId());
        userInfo.setStatus(UserStatusEnum.ENABLE.getStatus());
        this.userInfoMapper.insert(userInfo);
        return null;
    });
}
```

#### 3. 在用户登录中使用分布式锁

```java
@Override
public UserInfoVO login(String email, String password) {
    String lockKey = "lock:user:login:" + email;
    
    return distributedLockUtil.executeWithLock(lockKey, 3, 10, () -> {
        UserInfo userInfo = this.userInfoMapper.selectByEmail(email);
        
        if(null == userInfo || !userInfo.getPassword().equals(password)){
            throw new BusinessException("账号或密码错误");
        }
        if(UserStatusEnum.DISABLE.getStatus().equals(userInfo.getStatus())){
            throw new BusinessException("账号已被禁用");
        }
        
        // 检查是否已在别处登录（需要加锁）
        if(userInfo.getLastLoginTime() != null && userInfo.getLastOffTime() <= userInfo.getLastLoginTime()){
            throw new BusinessException("此账号已在别处登录，请退出后再登录");
        }
        
        // 更新登录时间
        long now = System.currentTimeMillis();
        UserInfo update = new UserInfo();
        update.setLastLoginTime(now);
        this.userInfoMapper.updateByUserId(update, userInfo.getUserId());
        
        TokenUserInfoDto tokenUserInfoDto = CopyTools.copy(userInfo, TokenUserInfoDto.class);
        String token = StringTools.encodeByMD5(tokenUserInfoDto.getUserId()+StringTools.getRandomString(Constants.LENGTH_20));
        tokenUserInfoDto.setToken(token);
        tokenUserInfoDto.setMyMeetingNo(userInfo.getMeetingNo());
        tokenUserInfoDto.setAdmin(appConfig.getAdminEmails().contains(email));
        
        redisComponent.saveTokenUserInfoDto(tokenUserInfoDto);
        
        UserInfoVO userInfoVO = CopyTools.copy(userInfo, UserInfoVO.class);
        userInfoVO.setToken(token);
        userInfoVO.setAdmin(tokenUserInfoDto.getAdmin());
        
        return userInfoVO;
    });
}
```

---

## 📝 简历描述建议

### 修改后的描述：

**原描述**：
> 7. 使用 Redis 存储用户 Token 和会议成员状态，通过 Redisson 实现分布式锁和发布订阅；设计 Token 认证机制，支持单点登录检测，通过 lastLoginTime 和 lastOffTime 判断用户在线状态。

**修改为**：
> 7. 使用 Redis 存储用户 Token 和会议成员状态，通过 Redisson 实现发布订阅机制，支持分布式环境下的实时消息推送；使用 Redisson 分布式锁解决用户注册、登录等并发场景下的数据一致性问题；设计 Token 认证机制，支持单点登录检测，通过 lastLoginTime 和 lastOffTime 判断用户在线状态。

或者更详细：
> 7. 使用 Redis 存储用户 Token 和会议成员状态，通过 Redisson 的 RTopic 实现发布订阅机制，支持分布式环境下的实时消息推送；使用 Redisson 分布式锁解决用户注册、登录等并发场景下的数据一致性问题，通过 tryLock 机制避免重复注册和并发登录冲突；设计 Token 认证机制，支持单点登录检测，通过 lastLoginTime 和 lastOffTime 判断用户在线状态。

---

## 🎯 总结

### 分布式 vs 单机
- **单机**：1台服务器，所有请求都在这一台处理
- **分布式**：多台服务器，请求可以分发到任意一台处理

### 为什么需要分布式锁
在分布式环境下，多台服务器可能同时操作同一数据，需要锁来保证数据一致性。

### 你的项目中的分布式场景
1. **消息推送**：多台服务器通过 Redis/RabbitMQ 通信（已实现）
2. **数据一致性**：用户注册、登录等需要分布式锁（可以添加）

### 实现建议
使用 Redisson 的分布式锁，简单易用，性能好，支持自动续期和看门狗机制。


